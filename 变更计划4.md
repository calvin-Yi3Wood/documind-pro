æç¤ºè¯ 23: æ–‡ä»¶è§£æç³»ç»Ÿ (DOCX/PDF/XLSX å¯¼å…¥)
è¯·åœ¨ documind-pro é¡¹ç›®ä¸­å®ç°å®Œæ•´çš„æ–‡ä»¶è§£æç³»ç»Ÿã€‚

## éœ€æ±‚
æ”¯æŒå¯¼å…¥ DOCXã€PDFã€XLSX æ–‡ä»¶å¹¶è½¬æ¢ä¸ºå¯ç¼–è¾‘çš„ HTML å†…å®¹ã€‚

## å®ç°æ­¥éª¤

### 1. å®‰è£…ä¾èµ–
```bash
npm install mammoth pdfjs-dist xlsx

2. åˆ›å»ºæ–‡ä»¶è§£ææœåŠ¡
åˆ›å»º services/file-parser/index.ts:

import mammoth from 'mammoth';
import * as XLSX from 'xlsx';

export type SupportedFileType = 'docx' | 'pdf' | 'xlsx' | 'xls' | 'txt' | 'md' | 'html';

export interface ParseResult {
  content: string;
  type: SupportedFileType;
  metadata?: {
    pageCount?: number;
    sheetCount?: number;
    truncated?: boolean;
  };
}

export async function parseFile(file: File): Promise<ParseResult> {
  const fileName = file.name.toLowerCase();
  
  if (fileName.endsWith('.docx')) {
    return parseDocx(file);
  } else if (fileName.endsWith('.pdf')) {
    return parsePdf(file);
  } else if (fileName.endsWith('.xlsx') || fileName.endsWith('.xls')) {
    return parseExcel(file);
  } else {
    // é»˜è®¤ä½œä¸ºæ–‡æœ¬å¤„ç†
    const text = await file.text();
    return { content: `<p>${text.replace(/\n/g, '</p><p>')}</p>`, type: 'txt' };
  }
}

async function parseDocx(file: File): Promise<ParseResult> {
  const arrayBuffer = await file.arrayBuffer();
  const result = await mammoth.convertToHtml({ arrayBuffer });
  return {
    content: result.value || '<p>ï¼ˆæ–‡æ¡£å†…å®¹ä¸ºç©ºï¼‰</p>',
    type: 'docx'
  };
}

async function parsePdf(file: File): Promise<ParseResult> {
  const pdfjsLib = await import('pdfjs-dist');
  pdfjsLib.GlobalWorkerOptions.workerSrc = '/pdf.worker.min.js';
  
  const arrayBuffer = await file.arrayBuffer();
  const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
  
  let fullText = '';
  for (let i = 1; i <= pdf.numPages; i++) {
    const page = await pdf.getPage(i);
    const textContent = await page.getTextContent();
    const pageText = textContent.items.map((item: any) => item.str).join(' ');
    fullText += `<p>${pageText}</p>`;
  }
  
  return {
    content: fullText,
    type: 'pdf',
    metadata: { pageCount: pdf.numPages }
  };
}

async function parseExcel(file: File): Promise<ParseResult> {
  const arrayBuffer = await file.arrayBuffer();
  const workbook = XLSX.read(arrayBuffer, { type: 'array' });
  
  const MAX_ROWS = 500;
  let htmlContent = '<div style="overflow-x: auto;">';
  let truncated = false;
  
  workbook.SheetNames.forEach((sheetName, index) => {
    const worksheet = workbook.Sheets[sheetName];
    const range = XLSX.utils.decode_range(worksheet['!ref'] || 'A1');
    const totalRows = range.e.r - range.s.r + 1;
    
    if (totalRows > MAX_ROWS) {
      truncated = true;
      range.e.r = range.s.r + MAX_ROWS - 1;
      worksheet['!ref'] = XLSX.utils.encode_range(range);
      htmlContent += `<p style="color: #f59e0b;">âš ï¸ å·¥ä½œè¡¨"${sheetName}"å…±${totalRows}è¡Œï¼Œä»…å¯¼å…¥å‰${MAX_ROWS}è¡Œ</p>`;
    }
    
    htmlContent += `<h3>å·¥ä½œè¡¨ ${index + 1}: ${sheetName}</h3>`;
    htmlContent += XLSX.utils.sheet_to_html(worksheet);
  });
  
  htmlContent += '</div>';
  
  return {
    content: htmlContent,
    type: 'xlsx',
    metadata: { sheetCount: workbook.SheetNames.length, truncated }
  };
}

3. åˆ›å»ºå¯¼å…¥æŒ‰é’®ç»„ä»¶
åœ¨ components/features/editor/ImportButton.tsx:

'use client';

import { useRef, useState } from 'react';
import { Button } from '@/components/ui/Button';
import { parseFile } from '@/services/file-parser';
import { Spinner } from '@/components/ui/Spinner';

interface ImportButtonProps {
  onImport: (content: string, fileName: string) => void;
}

export function ImportButton({ onImport }: ImportButtonProps) {
  const fileInputRef = useRef<HTMLInputElement>(null);
  const [isLoading, setIsLoading] = useState(false);
  
  const handleFileSelect = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;
    
    setIsLoading(true);
    try {
      const result = await parseFile(file);
      onImport(result.content, file.name.replace(/\.[^/.]+$/, ''));
    } catch (error) {
      console.error('æ–‡ä»¶è§£æå¤±è´¥:', error);
      alert('æ–‡ä»¶è§£æå¤±è´¥ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶æ ¼å¼');
    } finally {
      setIsLoading(false);
      if (fileInputRef.current) fileInputRef.current.value = '';
    }
  };
  
  return (
    <>
      <input
        ref={fileInputRef}
        type="file"
        accept=".docx,.pdf,.xlsx,.xls,.txt,.md,.html"
        onChange={handleFileSelect}
        className="hidden"
      />
      <Button
        variant="ghost"
        size="sm"
        onClick={() => fileInputRef.current?.click()}
        disabled={isLoading}
      >
        {isLoading ? <Spinner size="sm" /> : <i className="fas fa-file-import mr-2" />}
        å¯¼å…¥æ–‡ä»¶
      </Button>
    </>
  );
}

4. é›†æˆåˆ° Dashboard
åœ¨ dashboard/page.tsx çš„é¡¶éƒ¨å¯¼èˆªæ æ·»åŠ å¯¼å…¥æŒ‰é’®ï¼Œè°ƒç”¨ ImportButton ç»„ä»¶ã€‚

5. å¤åˆ¶ PDF Worker æ–‡ä»¶
å°† node_modules/pdfjs-dist/build/pdf.worker.min.js å¤åˆ¶åˆ° public/ ç›®å½•ã€‚

éªŒè¯
æµ‹è¯•å¯¼å…¥ .docx æ–‡ä»¶
æµ‹è¯•å¯¼å…¥ .pdf æ–‡ä»¶
æµ‹è¯•å¯¼å…¥ .xlsx æ–‡ä»¶
éªŒè¯å¤§æ–‡ä»¶çš„è¡Œæ•°é™åˆ¶

---

### æç¤ºè¯ 24: å¤šæ ¼å¼å¯¼å‡ºç³»ç»Ÿ


è¯·åœ¨ documind-pro é¡¹ç›®ä¸­å®ç°å®Œæ•´çš„å¤šæ ¼å¼å¯¼å‡ºåŠŸèƒ½ã€‚

éœ€æ±‚
æ”¯æŒå°†æ–‡æ¡£å¯¼å‡ºä¸º HTMLã€Markdownã€TXTã€DOCã€XLSXã€PDF æ ¼å¼ã€‚

å®ç°æ­¥éª¤
1. åˆ›å»ºå¯¼å‡ºæœåŠ¡
åˆ›å»º services/export/index.ts:

export type ExportFormat = 'html' | 'md' | 'txt' | 'doc' | 'xlsx' | 'pdf';

export interface ExportOptions {
  title: string;
  content: string;
  format: ExportFormat;
}

export function exportDocument({ title, content, format }: ExportOptions): void {
  switch (format) {
    case 'html':
      exportAsHtml(title, content);
      break;
    case 'md':
      exportAsMarkdown(title, content);
      break;
    case 'txt':
      exportAsText(title, content);
      break;
    case 'doc':
      exportAsDoc(title, content);
      break;
    case 'xlsx':
      exportAsExcel(title, content);
      break;
    case 'pdf':
      exportAsPdf();
      break;
  }
}

function downloadFile(content: string, filename: string, mimeType: string) {
  const blob = new Blob([content], { type: mimeType });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

function exportAsHtml(title: string, content: string) {
  const htmlContent = `<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${title}</title>
  <style>
    body { max-width: 800px; margin: 40px auto; padding: 20px; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; line-height: 1.6; color: #333; }
    h1, h2, h3, h4, h5, h6 { margin-top: 1.5em; margin-bottom: 0.5em; font-weight: 600; }
    p { margin: 1em 0; }
    img { max-width: 100%; height: auto; border-radius: 8px; }
    table { border-collapse: collapse; width: 100%; }
    td, th { border: 1px solid #ddd; padding: 8px; }
  </style>
</head>
<body>
  ${content}
  <hr style="margin-top: 40px; border: none; border-top: 1px solid #ddd;">
  <p style="text-align: center; color: #999; font-size: 12px;">å¯¼å‡ºæ—¶é—´: ${new Date().toLocaleString()} | ç”± DocuFusion ç”Ÿæˆ</p>
</body>
</html>`;
  downloadFile(htmlContent, `${title}.html`, 'text/html;charset=utf-8');
}

function exportAsMarkdown(title: string, content: string) {
  const tempDiv = document.createElement('div');
  tempDiv.innerHTML = content;
  
  let markdown = `# ${title}\n\n`;
  
  const processNode = (node: Node): string => {
    if (node.nodeType === Node.TEXT_NODE) {
      return node.textContent || '';
    }
    
    if (node.nodeType === Node.ELEMENT_NODE) {
      const el = node as HTMLElement;
      const tag = el.tagName.toLowerCase();
      
      switch (tag) {
        case 'h1': return `# ${el.textContent}\n\n`;
        case 'h2': return `## ${el.textContent}\n\n`;
        case 'h3': return `### ${el.textContent}\n\n`;
        case 'h4': return `#### ${el.textContent}\n\n`;
        case 'p': return `${el.textContent}\n\n`;
        case 'strong':
        case 'b': return `**${el.textContent}**`;
        case 'em':
        case 'i': return `*${el.textContent}*`;
        case 'code': return `\`${el.textContent}\``;
        case 'pre': return `\`\`\`\n${el.textContent}\n\`\`\`\n\n`;
        case 'ul':
        case 'ol':
          let listResult = '';
          Array.from(el.children).forEach((li, idx) => {
            const prefix = tag === 'ul' ? '-' : `${idx + 1}.`;
            listResult += `${prefix} ${li.textContent}\n`;
          });
          return listResult + '\n';
        case 'img':
          return `![${el.getAttribute('alt') || 'å›¾ç‰‡'}](${el.getAttribute('src') || ''})\n\n`;
        case 'br': return '\n';
        default:
          let result = '';
          el.childNodes.forEach(child => { result += processNode(child); });
          return result;
      }
    }
    return '';
  };
  
  tempDiv.childNodes.forEach(child => { markdown += processNode(child); });
  markdown += `\n---\n\n*å¯¼å‡ºæ—¶é—´: ${new Date().toLocaleString()} | ç”± DocuFusion ç”Ÿæˆ*\n`;
  
  downloadFile(markdown, `${title}.md`, 'text/markdown;charset=utf-8');
}

function exportAsText(title: string, content: string) {
  const tempDiv = document.createElement('div');
  tempDiv.innerHTML = content;
  const plainText = tempDiv.textContent || '';
  const textContent = `${title}\n${'='.repeat(title.length)}\n\n${plainText}\n\n---\nå¯¼å‡ºæ—¶é—´: ${new Date().toLocaleString()}`;
  downloadFile(textContent, `${title}.txt`, 'text/plain;charset=utf-8');
}

function exportAsDoc(title: string, content: string) {
  const docContent = `
<html xmlns:o='urn:schemas-microsoft-com:office:office' xmlns:w='urn:schemas-microsoft-com:office:word' xmlns='http://www.w3.org/TR/REC-html40'>
<head><meta charset='utf-8'><title>${title}</title></head>
<body>${content}</body>
</html>`;
  downloadFile(docContent, `${title}.doc`, 'application/msword');
}

function exportAsExcel(title: string, content: string) {
  // éœ€è¦ xlsx åº“
  const XLSX = (window as any).XLSX;
  if (!XLSX) {
    alert('Excelå¯¼å‡ºåŠŸèƒ½æœªåŠ è½½ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•');
    return;
  }
  
  const tempDiv = document.createElement('div');
  tempDiv.innerHTML = content;
  const tables = tempDiv.querySelectorAll('table');
  
  if (tables.length === 0) {
    alert('æ–‡æ¡£ä¸­æ²¡æœ‰è¡¨æ ¼ï¼Œæ— æ³•å¯¼å‡ºä¸ºExcelæ ¼å¼');
    return;
  }
  
  const wb = XLSX.utils.book_new();
  tables.forEach((table, index) => {
    const ws = XLSX.utils.table_to_sheet(table);
    XLSX.utils.book_append_sheet(wb, ws, `Sheet${index + 1}`);
  });
  
  XLSX.writeFile(wb, `${title}.xlsx`);
}

function exportAsPdf() {
  window.print();
}

2. åˆ›å»ºå¯¼å‡ºèœå•ç»„ä»¶
åˆ›å»º components/features/editor/ExportMenu.tsx:

'use client';

import { useState } from 'react';
import { Button } from '@/components/ui/Button';
import { Dropdown } from '@/components/ui/Dropdown';
import { exportDocument, ExportFormat } from '@/services/export';

interface ExportMenuProps {
  title: string;
  content: string;
}

const EXPORT_OPTIONS: { format: ExportFormat; label: string; icon: string }[] = [
  { format: 'html', label: 'HTML ç½‘é¡µ', icon: 'fa-code' },
  { format: 'md', label: 'Markdown', icon: 'fa-markdown' },
  { format: 'txt', label: 'çº¯æ–‡æœ¬ TXT', icon: 'fa-file-lines' },
  { format: 'doc', label: 'Word æ–‡æ¡£', icon: 'fa-file-word' },
  { format: 'xlsx', label: 'Excel è¡¨æ ¼', icon: 'fa-file-excel' },
  { format: 'pdf', label: 'PDF (æ‰“å°)', icon: 'fa-file-pdf' },
];

export function ExportMenu({ title, content }: ExportMenuProps) {
  const [isOpen, setIsOpen] = useState(false);
  
  const handleExport = (format: ExportFormat) => {
    exportDocument({ title, content, format });
    setIsOpen(false);
  };
  
  return (
    <div className="relative">
      <Button
        variant="ghost"
        size="sm"
        onClick={() => setIsOpen(!isOpen)}
      >
        <i className="fas fa-download mr-2" />
        å¯¼å‡º
        <i className="fas fa-chevron-down ml-2 text-xs" />
      </Button>
      
      {isOpen && (
        <div className="absolute right-0 mt-2 w-48 bg-white rounded-lg shadow-lg border border-bronze-200 py-1 z-50">
          {EXPORT_OPTIONS.map(({ format, label, icon }) => (
            <button
              key={format}
              onClick={() => handleExport(format)}
              className="w-full px-4 py-2 text-left text-sm text-bronze-700 hover:bg-bronze-50 flex items-center gap-3"
            >
              <i className={`fas ${icon} w-4`} />
              {label}
            </button>
          ))}
        </div>
      )}
    </div>
  );
}

3. åœ¨ next.config.ts æ·»åŠ æ‰“å°æ ·å¼
// åœ¨ globals.css æˆ–å•ç‹¬çš„ print.css ä¸­æ·»åŠ 
@media print {
  header, aside, .no-print { display: none !important; }
  main { margin: 0 !important; padding: 0 !important; }
  body { background: white !important; }
}

4. é›†æˆåˆ° Dashboard
åœ¨é¡¶éƒ¨å¯¼èˆªæ æ·»åŠ  ExportMenu ç»„ä»¶ã€‚

éªŒè¯
æµ‹è¯•æ¯ç§æ ¼å¼çš„å¯¼å‡º
éªŒè¯ PDF æ‰“å°é¢„è§ˆæ•ˆæœ
æ£€æŸ¥ Excel å¯¼å‡ºè¡¨æ ¼æ•°æ®

---

### æç¤ºè¯ 25: AI å·®å¼‚ç¼–è¾‘ç³»ç»Ÿ (æ ¸å¿ƒåŠŸèƒ½)


è¯·åœ¨ documind-pro é¡¹ç›®ä¸­å®ç° AI å·®å¼‚ç¼–è¾‘ç³»ç»Ÿï¼Œè¿™æ˜¯æœ€é‡è¦çš„æ ¸å¿ƒåŠŸèƒ½ä¹‹ä¸€ã€‚

éœ€æ±‚
å½“ AI å¯¹é€‰ä¸­æ–‡æœ¬æå‡ºä¿®æ”¹å»ºè®®æ—¶ï¼Œæ˜¾ç¤ºå¯¹æ¯” UIï¼Œæ”¯æŒå¤šæ–¹æ¡ˆé€‰æ‹©ã€æ¥å—/æ‹’ç»ä¿®æ”¹ã€‚

å®ç°æ­¥éª¤
1. åˆ›å»ºå·®å¼‚ç¼–è¾‘ç±»å‹
åˆ›å»º types/diff.ts:

export interface DiffOption {
  id: string;
  originalText: string;
  newText: string;
  index: number;
}

export interface DiffContainer {
  id: string;
  options: DiffOption[];
  position: {
    startOffset: number;
    endOffset: number;
  };
}

2. åˆ›å»ºå·®å¼‚ç¼–è¾‘ç»„ä»¶
åˆ›å»º components/features/editor/DiffEditor.tsx:

'use client';

import { useState } from 'react';
import { Button } from '@/components/ui/Button';

interface DiffOption {
  index: number;
  newText: string;
}

interface DiffEditorProps {
  diffId: string;
  originalText: string;
  options: DiffOption[];
  onAccept: (diffId: string, optionIndex: number, newText: string) => void;
  onReject: (diffId: string) => void;
  onRejectOption: (diffId: string, optionIndex: number) => void;
}

export function DiffEditor({
  diffId,
  originalText,
  options,
  onAccept,
  onReject,
  onRejectOption,
}: DiffEditorProps) {
  const [expandedOption, setExpandedOption] = useState<number | null>(
    options.length === 1 ? 0 : null
  );

  return (
    <div
      className="ai-diff-container my-4 border-2 border-orange-300 rounded-xl overflow-hidden bg-gradient-to-br from-orange-50 to-amber-50 shadow-lg"
      contentEditable={false}
      data-diff-id={diffId}
    >
      {/* å¤´éƒ¨ */}
      <div className="flex items-center justify-between px-4 py-3 bg-gradient-to-r from-orange-500 to-amber-500 text-white">
        <div className="flex items-center gap-2">
          <i className="fas fa-wand-magic-sparkles" />
          <span className="font-medium">
            AI ä¿®æ”¹å»ºè®® {options.length > 1 ? `(${options.length}ä¸ªæ–¹æ¡ˆ)` : ''}
          </span>
        </div>
        <button
          onClick={() => onReject(diffId)}
          className="flex items-center gap-1.5 px-3 py-1 bg-white/20 hover:bg-white/30 rounded-lg text-sm transition-colors"
        >
          <i className="fas fa-undo" />
          æ¢å¤åŸæ–‡
        </button>
      </div>

      {/* åŸæ–‡æ˜¾ç¤º */}
      <div className="px-4 py-3 bg-red-50 border-b border-red-200">
        <div className="flex items-center gap-2 text-red-600 text-sm font-medium mb-2">
          <i className="fas fa-minus-circle" />
          åŸæ–‡
        </div>
        <div className="text-red-700 line-through opacity-75">
          {originalText}
        </div>
      </div>

      {/* ä¿®æ”¹æ–¹æ¡ˆ */}
      <div className="divide-y divide-orange-200">
        {options.map((option, idx) => (
          <div
            key={idx}
            className={`transition-all ${
              expandedOption === idx ? 'bg-green-50' : 'bg-white hover:bg-orange-50'
            }`}
          >
            {/* æ–¹æ¡ˆæ ‡é¢˜ */}
            {options.length > 1 && (
              <button
                onClick={() => setExpandedOption(expandedOption === idx ? null : idx)}
                className="w-full px-4 py-2 flex items-center justify-between text-left"
              >
                <span className="flex items-center gap-2 text-orange-600 font-medium">
                  <i className="fas fa-lightbulb" />
                  æ–¹æ¡ˆ {idx + 1}
                </span>
                <i
                  className={`fas fa-chevron-down transition-transform ${
                    expandedOption === idx ? 'rotate-180' : ''
                  }`}
                />
              </button>
            )}

            {/* æ–¹æ¡ˆå†…å®¹ */}
            <div
              className={`px-4 pb-3 ${
                options.length > 1 && expandedOption !== idx ? 'hidden' : ''
              }`}
            >
              <div className="flex items-center gap-2 text-green-600 text-sm font-medium mb-2">
                <i className="fas fa-plus-circle" />
                ä¿®æ”¹å
              </div>
              <div className="text-green-700 bg-green-100 rounded-lg p-3 mb-3">
                {option.newText}
              </div>

              {/* æ“ä½œæŒ‰é’® */}
              <div className="flex items-center gap-2">
                <Button
                  variant="primary"
                  size="sm"
                  onClick={() => onAccept(diffId, idx, option.newText)}
                  className="flex-1"
                >
                  <i className="fas fa-check mr-2" />
                  é‡‡ç”¨æ­¤ä¿®æ”¹
                </Button>
                {options.length > 1 && (
                  <Button
                    variant="ghost"
                    size="sm"
                    onClick={() => onRejectOption(diffId, idx)}
                  >
                    <i className="fas fa-times" />
                  </Button>
                )}
              </div>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}

3. åˆ›å»ºå·®å¼‚ç¼–è¾‘ Hook
åˆ›å»º hooks/useDiffEditor.ts:

import { useState, useCallback, useRef } from 'react';

interface DiffState {
  id: string;
  originalText: string;
  options: { index: number; newText: string }[];
  range: Range | null;
}

export function useDiffEditor(onContentChange?: (html: string) => void) {
  const [activeDiffs, setActiveDiffs] = useState<Map<string, DiffState>>(new Map());
  const editorRef = useRef<HTMLDivElement | null>(null);

  // è§£æ AI è¿”å›çš„å¤šæ–¹æ¡ˆå†…å®¹
  const parseAISuggestions = useCallback((content: string): string[] => {
    const suggestions: string[] = [];
    
    // åŒ¹é… "æ–¹æ¡ˆä¸€:" "æ–¹æ¡ˆ1:" ç­‰æ ¼å¼
    const regex = /æ–¹æ¡ˆ[ä¸€äºŒä¸‰å››äº”1-5][:ï¼š]\s*([\s\S]*?)(?=æ–¹æ¡ˆ[ä¸€äºŒä¸‰å››äº”1-5][:ï¼š]|$)/g;
    let match;
    
    while ((match = regex.exec(content)) !== null) {
      const text = match[1].trim()
        .replace(/^```html\n?/gm, '')
        .replace(/^```\n?/gm, '')
        .replace(/\n{2,}/g, '\n');
      if (text) suggestions.push(text);
    }
    
    // å¦‚æœæ²¡æœ‰æ–¹æ¡ˆæ ¼å¼ï¼Œæ•´ä¸ªå†…å®¹ä½œä¸ºå•ä¸€å»ºè®®
    if (suggestions.length === 0) {
      const cleaned = content
        .replace(/^```html\n?/gm, '')
        .replace(/^```\n?/gm, '')
        .trim();
      if (cleaned) suggestions.push(cleaned);
    }
    
    return suggestions;
  }, []);

  // åˆ›å»ºå·®å¼‚ç¼–è¾‘
  const createDiff = useCallback((
    originalText: string,
    aiContent: string,
    savedRange?: Range | null
  ) => {
    const suggestions = parseAISuggestions(aiContent);
    if (suggestions.length === 0) return null;

    const diffId = `diff-${Date.now()}-${Math.random().toString(36).slice(2, 6)}`;
    const diffState: DiffState = {
      id: diffId,
      originalText,
      options: suggestions.map((text, idx) => ({ index: idx, newText: text })),
      range: savedRange || null,
    };

    setActiveDiffs(prev => new Map(prev).set(diffId, diffState));
    return diffState;
  }, [parseAISuggestions]);

  // æ¥å—ä¿®æ”¹
  const acceptDiff = useCallback((diffId: string, optionIndex: number, newText: string) => {
    const diff = activeDiffs.get(diffId);
    if (!diff) return;

    // åœ¨ç¼–è¾‘å™¨ä¸­æ‰¾åˆ°å·®å¼‚å®¹å™¨å¹¶æ›¿æ¢
    const container = document.querySelector(`[data-diff-id="${diffId}"]`);
    if (container && editorRef.current) {
      // åˆ›å»ºæ–°çš„æ–‡æœ¬èŠ‚ç‚¹
      const textNode = document.createTextNode(newText);
      container.replaceWith(textNode);
      
      // æ›´æ–°å†…å®¹
      if (onContentChange) {
        onContentChange(editorRef.current.innerHTML);
      }
    }

    // ç§»é™¤å·®å¼‚çŠ¶æ€
    setActiveDiffs(prev => {
      const next = new Map(prev);
      next.delete(diffId);
      return next;
    });
  }, [activeDiffs, onContentChange]);

  // æ‹’ç»ä¿®æ”¹ï¼ˆæ¢å¤åŸæ–‡ï¼‰
  const rejectDiff = useCallback((diffId: string) => {
    const diff = activeDiffs.get(diffId);
    if (!diff) return;

    const container = document.querySelector(`[data-diff-id="${diffId}"]`);
    if (container && editorRef.current) {
      const textNode = document.createTextNode(diff.originalText);
      container.replaceWith(textNode);
      
      if (onContentChange) {
        onContentChange(editorRef.current.innerHTML);
      }
    }

    setActiveDiffs(prev => {
      const next = new Map(prev);
      next.delete(diffId);
      return next;
    });
  }, [activeDiffs, onContentChange]);

  // æ‹’ç»å•ä¸ªæ–¹æ¡ˆ
  const rejectOption = useCallback((diffId: string, optionIndex: number) => {
    setActiveDiffs(prev => {
      const next = new Map(prev);
      const diff = next.get(diffId);
      if (diff) {
        diff.options = diff.options.filter(opt => opt.index !== optionIndex);
        if (diff.options.length === 0) {
          // æ²¡æœ‰æ–¹æ¡ˆäº†ï¼Œæ¢å¤åŸæ–‡
          rejectDiff(diffId);
        }
      }
      return next;
    });
  }, [rejectDiff]);

  return {
    activeDiffs,
    editorRef,
    createDiff,
    acceptDiff,
    rejectDiff,
    rejectOption,
  };
}

4. åˆ›å»ºå·®å¼‚ CSS æ ·å¼
åœ¨ app/globals.css æ·»åŠ :

/* AI å·®å¼‚ç¼–è¾‘æ ·å¼ */
.ai-diff-container {
  user-select: none;
  -webkit-user-select: none;
}

.ai-diff-container * {
  pointer-events: auto;
}

/* é˜²æ­¢åœ¨å·®å¼‚å®¹å™¨å†…ç¼–è¾‘ */
.ai-diff-container[contenteditable="false"] {
  cursor: default;
}

/* é«˜äº®åŠ¨ç”» */
@keyframes diff-highlight {
  0%, 100% { box-shadow: 0 0 0 2px rgba(249, 115, 22, 0.3); }
  50% { box-shadow: 0 0 0 4px rgba(249, 115, 22, 0.5); }
}

.ai-diff-container {
  animation: diff-highlight 2s ease-in-out infinite;
}

5. é›†æˆåˆ° FloatingAgent
ä¿®æ”¹ FloatingAgent.tsxï¼Œåœ¨ AI è¿”å›ä¿®æ”¹å»ºè®®æ—¶ï¼š

// åœ¨ handleSendMessage ä¸­ï¼Œæ£€æµ‹æ˜¯å¦æ˜¯ç¼–è¾‘ä»»åŠ¡
if (selectionTask?.action === 'edit' || selectionTask?.action === 'rewrite') {
  const diff = createDiff(selectionTask.text, aiResponse, savedRange);
  if (diff) {
    // åœ¨ç¼–è¾‘å™¨ä¸­æ’å…¥å·®å¼‚ UI
    insertDiffToEditor(diff);
  }
}

6. ä¿å­˜é€‰åŒºåŠŸèƒ½
åœ¨ç¼–è¾‘å™¨ä¸­æ·»åŠ é€‰åŒºä¿å­˜ï¼š

const savedSelectionRef = useRef<{
  range: Range | null;
  text: string;
  contextBefore: string;
  contextAfter: string;
}>({ range: null, text: '', contextBefore: '', contextAfter: '' });

// å½“ç”¨æˆ·é€‰ä¸­æ–‡æœ¬å¹¶å‘èµ· AI ç¼–è¾‘æ—¶ï¼Œä¿å­˜é€‰åŒº
const saveSelection = () => {
  const selection = window.getSelection();
  if (selection && selection.rangeCount > 0) {
    const range = selection.getRangeAt(0);
    savedSelectionRef.current = {
      range: range.cloneRange(),
      text: selection.toString(),
      contextBefore: /* è·å–å‰æ–‡ */,
      contextAfter: /* è·å–åæ–‡ */,
    };
  }
};

éªŒè¯
é€‰ä¸­æ–‡æœ¬ï¼Œç‚¹å‡»"AIæ”¹å†™"
éªŒè¯å·®å¼‚ UI æ­£ç¡®æ˜¾ç¤ºåŸæ–‡å’Œä¿®æ”¹å»ºè®®
æµ‹è¯•å¤šæ–¹æ¡ˆå±•å¼€/æŠ˜å 
æµ‹è¯•"é‡‡ç”¨ä¿®æ”¹"åŠŸèƒ½
æµ‹è¯•"æ¢å¤åŸæ–‡"åŠŸèƒ½
éªŒè¯ç¼–è¾‘åå†…å®¹æ­£ç¡®æ›´æ–°

---

### æç¤ºè¯ 26: è¡¥å……ç¼ºå¤±çš„ API è·¯ç”±


è¯·åœ¨ documind-pro é¡¹ç›®ä¸­è¡¥å……ä»¥ä¸‹ç¼ºå¤±çš„ API è·¯ç”±ã€‚

1. åˆ›å»º /api/ai/image è·¯ç”±
æ–‡ä»¶: app/api/ai/image/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth/config';

// AI å›¾ç‰‡ç”Ÿæˆ API
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    
    // å¼€å‘æ¨¡å¼è·³è¿‡è®¤è¯
    const isDevMode = process.env.NEXT_PUBLIC_DEV_MODE === 'true';
    if (!isDevMode && !session?.user) {
      return NextResponse.json({ error: 'æœªæˆæƒ' }, { status: 401 });
    }

    const { prompt, style, size } = await request.json();

    if (!prompt) {
      return NextResponse.json({ error: 'ç¼ºå°‘ prompt å‚æ•°' }, { status: 400 });
    }

    // ä½¿ç”¨ Gemini æˆ–å…¶ä»–å›¾ç‰‡ç”Ÿæˆ API
    const GEMINI_API_KEY = process.env.GEMINI_API_KEY;
    
    if (!GEMINI_API_KEY) {
      return NextResponse.json({ error: 'API å¯†é’¥æœªé…ç½®' }, { status: 500 });
    }

    // è¿™é‡Œè°ƒç”¨å®é™…çš„å›¾ç‰‡ç”Ÿæˆ API
    // ç¤ºä¾‹ï¼šè¿”å›æ¨¡æ‹Ÿæ•°æ®
    const response = await fetch(
      `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${GEMINI_API_KEY}`,
      {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          contents: [{
            parts: [{ text: `Generate an image: ${prompt}` }]
          }],
          generationConfig: {
            responseModalities: ['image', 'text']
          }
        })
      }
    );

    const data = await response.json();
    
    return NextResponse.json({
      success: true,
      imageUrl: data.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data
        ? `data:image/png;base64,${data.candidates[0].content.parts[0].inlineData.data}`
        : null,
      prompt,
    });

  } catch (error) {
    console.error('å›¾ç‰‡ç”Ÿæˆé”™è¯¯:', error);
    return NextResponse.json(
      { error: 'å›¾ç‰‡ç”Ÿæˆå¤±è´¥', details: String(error) },
      { status: 500 }
    );
  }
}

2. åˆ›å»º /api/documents è·¯ç”±
æ–‡ä»¶: app/api/documents/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth/config';
import { createServerClient } from '@/lib/supabase/server';
import { nanoid } from 'nanoid';

// è·å–æ–‡æ¡£åˆ—è¡¨
export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    const isDevMode = process.env.NEXT_PUBLIC_DEV_MODE === 'true';
    
    if (!isDevMode && !session?.user) {
      return NextResponse.json({ error: 'æœªæˆæƒ' }, { status: 401 });
    }

    const userId = session?.user?.id || 'dev-user-001';
    const supabase = await createServerClient();

    const { data: documents, error } = await supabase
      .from('documents')
      .select('id, title, preview, created_at, updated_at')
      .eq('user_id', userId)
      .order('updated_at', { ascending: false });

    if (error) throw error;

    return NextResponse.json({ documents: documents || [] });

  } catch (error) {
    console.error('è·å–æ–‡æ¡£åˆ—è¡¨é”™è¯¯:', error);
    return NextResponse.json(
      { error: 'è·å–æ–‡æ¡£åˆ—è¡¨å¤±è´¥' },
      { status: 500 }
    );
  }
}

// åˆ›å»ºæ–°æ–‡æ¡£
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    const isDevMode = process.env.NEXT_PUBLIC_DEV_MODE === 'true';
    
    if (!isDevMode && !session?.user) {
      return NextResponse.json({ error: 'æœªæˆæƒ' }, { status: 401 });
    }

    const userId = session?.user?.id || 'dev-user-001';
    const { title, content } = await request.json();

    const supabase = await createServerClient();
    const docId = nanoid();

    const { data, error } = await supabase
      .from('documents')
      .insert({
        id: docId,
        user_id: userId,
        title: title || 'æœªå‘½åæ–‡æ¡£',
        content: content || '',
        preview: (content || '').slice(0, 100),
      })
      .select()
      .single();

    if (error) throw error;

    return NextResponse.json({ document: data });

  } catch (error) {
    console.error('åˆ›å»ºæ–‡æ¡£é”™è¯¯:', error);
    return NextResponse.json(
      { error: 'åˆ›å»ºæ–‡æ¡£å¤±è´¥' },
      { status: 500 }
    );
  }
}

3. åˆ›å»º /api/documents/[id] è·¯ç”±
æ–‡ä»¶: app/api/documents/[id]/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth/config';
import { createServerClient } from '@/lib/supabase/server';

// è·å–å•ä¸ªæ–‡æ¡£
export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    const isDevMode = process.env.NEXT_PUBLIC_DEV_MODE === 'true';
    
    if (!isDevMode && !session?.user) {
      return NextResponse.json({ error: 'æœªæˆæƒ' }, { status: 401 });
    }

    const userId = session?.user?.id || 'dev-user-001';
    const supabase = await createServerClient();

    const { data: document, error } = await supabase
      .from('documents')
      .select('*')
      .eq('id', params.id)
      .eq('user_id', userId)
      .single();

    if (error || !document) {
      return NextResponse.json({ error: 'æ–‡æ¡£ä¸å­˜åœ¨' }, { status: 404 });
    }

    return NextResponse.json({ document });

  } catch (error) {
    console.error('è·å–æ–‡æ¡£é”™è¯¯:', error);
    return NextResponse.json({ error: 'è·å–æ–‡æ¡£å¤±è´¥' }, { status: 500 });
  }
}

// æ›´æ–°æ–‡æ¡£
export async function PUT(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    const isDevMode = process.env.NEXT_PUBLIC_DEV_MODE === 'true';
    
    if (!isDevMode && !session?.user) {
      return NextResponse.json({ error: 'æœªæˆæƒ' }, { status: 401 });
    }

    const userId = session?.user?.id || 'dev-user-001';
    const { title, content } = await request.json();

    const supabase = await createServerClient();

    const { data, error } = await supabase
      .from('documents')
      .update({
        title,
        content,
        preview: (content || '').slice(0, 100),
        updated_at: new Date().toISOString(),
      })
      .eq('id', params.id)
      .eq('user_id', userId)
      .select()
      .single();

    if (error) throw error;

    return NextResponse.json({ document: data });

  } catch (error) {
    console.error('æ›´æ–°æ–‡æ¡£é”™è¯¯:', error);
    return NextResponse.json({ error: 'æ›´æ–°æ–‡æ¡£å¤±è´¥' }, { status: 500 });
  }
}

// åˆ é™¤æ–‡æ¡£
export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    const isDevMode = process.env.NEXT_PUBLIC_DEV_MODE === 'true';
    
    if (!isDevMode && !session?.user) {
      return NextResponse.json({ error: 'æœªæˆæƒ' }, { status: 401 });
    }

    const userId = session?.user?.id || 'dev-user-001';
    const supabase = await createServerClient();

    const { error } = await supabase
      .from('documents')
      .delete()
      .eq('id', params.id)
      .eq('user_id', userId);

    if (error) throw error;

    return NextResponse.json({ success: true });

  } catch (error) {
    console.error('åˆ é™¤æ–‡æ¡£é”™è¯¯:', error);
    return NextResponse.json({ error: 'åˆ é™¤æ–‡æ¡£å¤±è´¥' }, { status: 500 });
  }
}

4. åˆ›å»º /api/user/profile è·¯ç”±
æ–‡ä»¶: app/api/user/profile/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth/config';
import { createServerClient } from '@/lib/supabase/server';

// è·å–ç”¨æˆ·ä¿¡æ¯
export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    const isDevMode = process.env.NEXT_PUBLIC_DEV_MODE === 'true';
    
    if (!isDevMode && !session?.user) {
      return NextResponse.json({ error: 'æœªæˆæƒ' }, { status: 401 });
    }

    if (isDevMode) {
      return NextResponse.json({
        user: {
          id: 'dev-user-001',
          email: 'dev@documind.local',
          name: 'å¼€å‘ç”¨æˆ·',
          avatar: null,
          plan: 'pro',
          createdAt: new Date().toISOString(),
        }
      });
    }

    const supabase = await createServerClient();
    
    const { data: user, error } = await supabase
      .from('users')
      .select('id, email, name, avatar_url, plan, created_at')
      .eq('id', session.user.id)
      .single();

    if (error) throw error;

    return NextResponse.json({
      user: {
        id: user.id,
        email: user.email,
        name: user.name,
        avatar: user.avatar_url,
        plan: user.plan,
        createdAt: user.created_at,
      }
    });

  } catch (error) {
    console.error('è·å–ç”¨æˆ·ä¿¡æ¯é”™è¯¯:', error);
    return NextResponse.json({ error: 'è·å–ç”¨æˆ·ä¿¡æ¯å¤±è´¥' }, { status: 500 });
  }
}

// æ›´æ–°ç”¨æˆ·ä¿¡æ¯
export async function PUT(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    const isDevMode = process.env.NEXT_PUBLIC_DEV_MODE === 'true';
    
    if (!isDevMode && !session?.user) {
      return NextResponse.json({ error: 'æœªæˆæƒ' }, { status: 401 });
    }

    const { name, avatar } = await request.json();
    
    if (isDevMode) {
      return NextResponse.json({ success: true });
    }

    const supabase = await createServerClient();

    const { error } = await supabase
      .from('users')
      .update({ name, avatar_url: avatar })
      .eq('id', session.user.id);

    if (error) throw error;

    return NextResponse.json({ success: true });

  } catch (error) {
    console.error('æ›´æ–°ç”¨æˆ·ä¿¡æ¯é”™è¯¯:', error);
    return NextResponse.json({ error: 'æ›´æ–°ç”¨æˆ·ä¿¡æ¯å¤±è´¥' }, { status: 500 });
  }
}

5. åˆ›å»ºç›®å½•ç»“æ„
mkdir -p app/api/ai/image
mkdir -p app/api/documents/[id]
mkdir -p app/api/user/profile

éªŒè¯
è¿è¡Œå¼€å‘æœåŠ¡å™¨åï¼Œæµ‹è¯•ä»¥ä¸‹ç«¯ç‚¹ï¼š

POST /api/ai/image
GET /api/documents
POST /api/documents
GET /api/documents/:id
PUT /api/documents/:id
DELETE /api/documents/:id
GET /api/user/profile
PUT /api/user/profile

---

### æç¤ºè¯ 27: AI ä¸Šä¸‹æ–‡ç®¡ç†åŠŸèƒ½


è¯·åœ¨ documind-pro é¡¹ç›®ä¸­å®ç° AI ä¸Šä¸‹æ–‡ç®¡ç†åŠŸèƒ½ã€‚

éœ€æ±‚
å…è®¸ç”¨æˆ·å°†é€‰ä¸­çš„æ–‡æœ¬æ·»åŠ åˆ° AI å¯¹è¯çš„ä¸Šä¸‹æ–‡ä¸­ï¼ŒAI å¯ä»¥åŸºäºè¿™äº›ä¸Šä¸‹æ–‡ç»™å‡ºæ›´ç²¾å‡†çš„å›ç­”ã€‚

å®ç°æ­¥éª¤
1. åˆ›å»ºä¸Šä¸‹æ–‡ç±»å‹
åœ¨ types/chat.ts æ·»åŠ :

export interface AIContextItem {
  id: string;
  text: string;
  addedAt: Date;
  used: boolean;  // æ˜¯å¦å·²è¢« AI ä½¿ç”¨
  source?: 'selection' | 'file' | 'manual';
}

2. åˆ›å»ºä¸Šä¸‹æ–‡ç®¡ç† Hook
åˆ›å»º hooks/useAIContext.ts:

import { useState, useCallback } from 'react';
import { nanoid } from 'nanoid';

export interface AIContextItem {
  id: string;
  text: string;
  addedAt: Date;
  used: boolean;
  source: 'selection' | 'file' | 'manual';
}

export function useAIContext() {
  const [contextItems, setContextItems] = useState<AIContextItem[]>([]);

  // æ·»åŠ ä¸Šä¸‹æ–‡
  const addContext = useCallback((text: string, source: AIContextItem['source'] = 'selection') => {
    const newItem: AIContextItem = {
      id: nanoid(),
      text: text.slice(0, 2000), // é™åˆ¶é•¿åº¦
      addedAt: new Date(),
      used: false,
      source,
    };
    setContextItems(prev => [...prev, newItem]);
    return newItem.id;
  }, []);

  // ç§»é™¤ä¸Šä¸‹æ–‡
  const removeContext = useCallback((id: string) => {
    setContextItems(prev => prev.filter(item => item.id !== id));
  }, []);

  // æ¸…ç©ºæ‰€æœ‰ä¸Šä¸‹æ–‡
  const clearContext = useCallback(() => {
    setContextItems([]);
  }, []);

  // æ ‡è®°ä¸ºå·²ä½¿ç”¨
  const markAsUsed = useCallback((ids: string[]) => {
    setContextItems(prev =>
      prev.map(item =>
        ids.includes(item.id) ? { ...item, used: true } : item
      )
    );
  }, []);

  // è·å–æœªä½¿ç”¨çš„ä¸Šä¸‹æ–‡æ–‡æœ¬
  const getUnusedContext = useCallback(() => {
    return contextItems
      .filter(item => !item.used)
      .map(item => item.text)
      .join('\n\n---\n\n');
  }, [contextItems]);

  // è·å–æ‰€æœ‰ä¸Šä¸‹æ–‡æ–‡æœ¬
  const getAllContext = useCallback(() => {
    return contextItems
      .map(item => item.text)
      .join('\n\n---\n\n');
  }, [contextItems]);

  return {
    contextItems,
    addContext,
    removeContext,
    clearContext,
    markAsUsed,
    getUnusedContext,
    getAllContext,
    hasContext: contextItems.length > 0,
  };
}

3. åˆ›å»ºä¸Šä¸‹æ–‡æ˜¾ç¤ºç»„ä»¶
åˆ›å»º components/features/ai-assistant/ContextPanel.tsx:

'use client';

import { Button } from '@/components/ui/Button';
import type { AIContextItem } from '@/hooks/useAIContext';

interface ContextPanelProps {
  items: AIContextItem[];
  onRemove: (id: string) => void;
  onClear: () => void;
}

export function ContextPanel({ items, onRemove, onClear }: ContextPanelProps) {
  if (items.length === 0) return null;

  return (
    <div className="border-t border-bronze-200 bg-orange-50/50">
      {/* å¤´éƒ¨ */}
      <div className="flex items-center justify-between px-3 py-2 border-b border-orange-200">
        <div className="flex items-center gap-2 text-sm text-orange-700">
          <i className="fas fa-layer-group" />
          <span>AI ä¸Šä¸‹æ–‡ ({items.length})</span>
        </div>
        <button
          onClick={onClear}
          className="text-xs text-orange-500 hover:text-orange-700"
        >
          æ¸…ç©ºå…¨éƒ¨
        </button>
      </div>

      {/* ä¸Šä¸‹æ–‡åˆ—è¡¨ */}
      <div className="max-h-32 overflow-y-auto p-2 space-y-1">
        {items.map(item => (
          <div
            key={item.id}
            className={`flex items-start gap-2 p-2 rounded-lg text-xs ${
              item.used
                ? 'bg-bronze-100 text-bronze-500'
                : 'bg-white text-bronze-700 border border-orange-200'
            }`}
          >
            <i
              className={`fas mt-0.5 ${
                item.used ? 'fa-check-circle text-green-500' : 'fa-quote-left text-orange-400'
              }`}
            />
            <div className="flex-1 line-clamp-2">{item.text}</div>
            <button
              onClick={() => onRemove(item.id)}
              className="p-1 text-bronze-400 hover:text-red-500"
            >
              <i className="fas fa-times" />
            </button>
          </div>
        ))}
      </div>
    </div>
  );
}

4. åœ¨é€‰åŒºå·¥å…·æ æ·»åŠ "æ·»åŠ åˆ°ä¸Šä¸‹æ–‡"æŒ‰é’®
ä¿®æ”¹ SelectionToolbar.tsx:

// æ·»åŠ æŒ‰é’®
<button
  onClick={() => onAddToContext?.(selectedText)}
  className="p-2 hover:bg-orange-100 rounded text-bronze-600"
  title="æ·»åŠ åˆ° AI ä¸Šä¸‹æ–‡"
>
  <i className="fas fa-plus-circle" />
</button>

5. é›†æˆåˆ° FloatingAgent
ä¿®æ”¹ FloatingAgent ä½¿ç”¨ä¸Šä¸‹æ–‡:

// åœ¨å‘é€æ¶ˆæ¯æ—¶ï¼ŒåŒ…å«ä¸Šä¸‹æ–‡
const buildSystemPrompt = () => {
  let prompt = 'ä½ æ˜¯ DocuFusion çš„ AI åŠ©æ‰‹...';
  
  if (hasContext) {
    prompt += `\n\nç”¨æˆ·æä¾›çš„å‚è€ƒä¸Šä¸‹æ–‡:\n${getAllContext()}`;
  }
  
  return prompt;
};

// å‘é€åæ ‡è®°ä¸Šä¸‹æ–‡ä¸ºå·²ä½¿ç”¨
const handleSend = async () => {
  // ... å‘é€é€»è¾‘
  
  // æ ‡è®°æ‰€æœ‰ä¸Šä¸‹æ–‡ä¸ºå·²ä½¿ç”¨
  markAsUsed(contextItems.map(i => i.id));
};

6. æ·»åŠ  Toast æç¤º
å½“ç”¨æˆ·æ·»åŠ ä¸Šä¸‹æ–‡æ—¶æ˜¾ç¤ºæç¤º:

const handleAddToContext = (text: string) => {
  addContext(text, 'selection');
  toast.success('å·²æ·»åŠ åˆ° AI ä¸Šä¸‹æ–‡');
};

éªŒè¯
é€‰ä¸­æ–‡æœ¬ï¼Œç‚¹å‡»"æ·»åŠ åˆ°ä¸Šä¸‹æ–‡"
éªŒè¯ä¸Šä¸‹æ–‡é¢æ¿æ˜¾ç¤º
å‘é€ AI æ¶ˆæ¯ï¼ŒéªŒè¯ä¸Šä¸‹æ–‡è¢«ä½¿ç”¨
æµ‹è¯•ç§»é™¤å•ä¸ªä¸Šä¸‹æ–‡
æµ‹è¯•æ¸…ç©ºå…¨éƒ¨ä¸Šä¸‹æ–‡

---

## æ€»ç»“

ä»¥ä¸Š 5 ä¸ªæç¤ºè¯è¦†ç›–äº†å‰©ä½™ 30% çš„æ ¸å¿ƒåŠŸèƒ½ï¼š

| æç¤ºè¯ | åŠŸèƒ½ | ä¼˜å…ˆçº§ |
|-------|------|--------|
| #23 | æ–‡ä»¶è§£æ (DOCX/PDF/XLSX) | ğŸ”´ é«˜ |
| #24 | å¤šæ ¼å¼å¯¼å‡º | ğŸ”´ é«˜ |
| #25 | AI å·®å¼‚ç¼–è¾‘ UI | ğŸ”´ é«˜ |
| #26 | è¡¥å…… API è·¯ç”± | ğŸŸ¡ ä¸­ |
| #27 | AI ä¸Šä¸‹æ–‡ç®¡ç† | ğŸŸ¡ ä¸­ |

å»ºè®®æŒ‰ä¼˜å…ˆçº§é¡ºåºæ‰§è¡Œï¼Œå®Œæˆåé¡¹ç›®è¿ç§»åº¦å°†è¾¾åˆ° **95%+**ã€‚